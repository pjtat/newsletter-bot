"""
Markdown digest generation and article tracking.
Creates formatted digest files and updates sent articles history.
"""

import json
import os
from datetime import datetime
from typing import List, Dict

from collector import Article
from scorer import LLMScorer


class MarkdownGenerator:
    """Generates markdown digests and tracks sent articles."""

    def __init__(self, scorer: LLMScorer, sent_articles_path: str):
        self.scorer = scorer
        self.sent_articles_path = sent_articles_path

    def generate_digest(self, articles: List[Article], profile: Dict, output_dir: str, dry_run: bool = False) -> str:
        """
        Generate markdown digest file.

        Args:
            articles: Ranked articles to include
            profile: Profile configuration
            output_dir: Directory to save digest
            dry_run: If True, don't save file or update tracking

        Returns:
            Path to generated file (or would-be path in dry-run)
        """
        if not articles:
            print("⚠️  No articles to generate digest")
            return ""

        # Generate summaries for each article
        print(f"\nGenerating summaries for {len(articles)} articles...")
        for i, article in enumerate(articles, 1):
            try:
                article.generated_summary = self.scorer.generate_summary(article, profile)
                print(f"  Generated summary {i}/{len(articles)}")
            except Exception as e:
                print(f"  ⚠️  Error generating summary: {e}")
                article.generated_summary = article.summary[:200] + "..."

        # Build markdown
        date_str = datetime.now().strftime('%Y-%m-%d')
        markdown = self._build_markdown(articles, profile, date_str)

        # Create filename
        profile_slug = profile['name'].lower().replace(' ', '-').replace('&', 'and')
        filename = f"{date_str}-{profile_slug}.md"
        filepath = os.path.join(output_dir, filename)

        if dry_run:
            print(f"\n[DRY RUN] Would save digest to: {filepath}")
            print(f"[DRY RUN] Would track {len(articles)} articles")
            return filepath

        # Save file
        os.makedirs(output_dir, exist_ok=True)
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(markdown)

        print(f"\n✓ Digest saved to: {filepath}")

        # Update sent articles tracking
        article_links = [article.link for article in articles]
        self._update_sent_articles(article_links)

        return filepath

    def _build_markdown(self, articles: List[Article], profile: Dict, date_str: str) -> str:
        """Build markdown content."""
        lines = []

        # Header
        lines.append(f"# {profile['name']}")
        lines.append(f"*Generated on {date_str}*\n")
        lines.append(f"{profile['description']}\n")
        lines.append(f"**Top {len(articles)} Articles**\n")
        lines.append("---\n")

        # Articles
        for i, article in enumerate(articles, 1):
            lines.append(f"## {i}. {article.title}\n")
            lines.append(f"**Source:** {article.source_name}")
            lines.append(f"**Published:** {article.published.strftime('%Y-%m-%d %H:%M UTC')}")
            lines.append(f"**Relevance Score:** {article.relevance_score}/100 | **Importance Score:** {article.importance_score}/100")
            lines.append(f"**Topic:** {article.main_topic}\n")
            lines.append(f"**Summary:** {article.generated_summary}\n")
            lines.append(f"[Read full article]({article.link})\n")
            lines.append("---\n")

        # Footer
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')
        lines.append(f"*Digest generated by News Curator on {timestamp}*")

        return "\n".join(lines)

    def _update_sent_articles(self, article_links: List[str]):
        """Update sent articles tracking file."""
        try:
            # Load existing
            with open(self.sent_articles_path, 'r') as f:
                data = json.load(f)

            # Add new articles
            existing = set(data.get('articles', []))
            existing.update(article_links)

            # Save
            data['articles'] = list(existing)
            with open(self.sent_articles_path, 'w') as f:
                json.dump(data, f, indent=2)

            print(f"✓ Updated tracking file with {len(article_links)} new articles")

        except Exception as e:
            print(f"⚠️  Error updating sent articles: {e}")
